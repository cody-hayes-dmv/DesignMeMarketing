generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model User {
  id             String       @id @default(cuid())
  createdAt      DateTime     @default(now())
  updatedAt      DateTime     @updatedAt
  email          String       @unique
  name           String?
  passwordHash   String?
  role           Role         @default(AGENCY)
  verified       Boolean      @default(false)
  invited        Boolean      @default(false)
  specialties    String?      @db.Text
  lastLoginAt    DateTime?
  clients        Client[]
  assignedTaksks Task[]       @relation("TaskAssignee")
  createdTass    Task[]       @relation("TaskCreator")
  taskComments   TaskComment[]
  tokens         Token[]
  memberships    UserAgency[]
  clientUsers    ClientUser[]
  invitedClientUsers ClientUser[] @relation("ClientUserInvitedBy")

  @@map("users")
}

model Agency {
  id                    String               @id @default(cuid())
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  name                  String
  subdomain             String?              @unique
  stripeCustomerId      String?              @db.VarChar(255)
  stripeSubscriptionId  String?              @db.VarChar(255)
  billingType           BillingType?         @default(paid)
  // Agency info (create form)
  website               String?              @db.VarChar(500)
  industry              String?              @db.VarChar(100)
  agencySize            String?              @db.VarChar(80)
  numberOfClients       Int?
  // Primary contact (also used for owner user)
  contactName           String?              @db.VarChar(255)
  contactEmail          String?              @db.VarChar(255)
  contactPhone          String?              @db.VarChar(50)
  contactJobTitle       String?              @db.VarChar(100)
  // Business address
  streetAddress         String?              @db.VarChar(255)
  city                  String?              @db.VarChar(100)
  state                 String?              @db.VarChar(100)
  zip                   String?              @db.VarChar(20)
  country               String?              @db.VarChar(100)
  // Subscription
  subscriptionTier      String?              @db.VarChar(50)
  customPricing         Decimal?             @db.Decimal(10, 2)
  internalNotes         String?              @db.Text
  // Additional questions (stored as JSON: referralSource, referralText, primaryGoals[], currentTools, etc.)
  onboardingData        String?              @db.LongText
  onboardingTemplates   OnboardingTemplate[]
  tasks                 Task[]
  tokens                Token[]
  members               UserAgency[]
  managedServices       ManagedService[]
  addOns                AgencyAddOn[]
  clientsBelongingToAgency Client[]           @relation("ClientsBelongingToAgency")

  @@map("agencies")
}

model UserAgency {
  id         String     @id @default(cuid())
  userId     String
  agencyId   String
  agencyRole AgencyRole @default(SPECIALIST)
  agency     Agency     @relation(fields: [agencyId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, agencyId])
  @@index([agencyId])
  @@index([userId])
  @@map("user_agencies")
}

model Task {
  id             String     @id @default(cuid())
  createdAt      DateTime   @default(now())
  updatedAt      DateTime   @updatedAt
  title          String
  description    String?    @db.Text
  category       String?
  dueDate        DateTime?
  status         TaskStatus @default(TODO)
  priority       String?
  estimatedHours Int?
  proof          String?    @db.LongText
  agencyId       String?
  createdById    String?
  assigneeId     String?
  clientId       String?
  comments       TaskComment[]
  agency         Agency?    @relation(fields: [agencyId], references: [id], onDelete: Cascade)
  assignee       User?      @relation("TaskAssignee", fields: [assigneeId], references: [id])
  client         Client?    @relation(fields: [clientId], references: [id])
  createdBy      User?      @relation("TaskCreator", fields: [createdById], references: [id])

  @@index([agencyId, status])
  @@index([assigneeId])
  @@index([clientId], map: "tasks_clientId_fkey")
  @@index([createdById], map: "tasks_createdById_fkey")
  @@map("tasks")
}

model TaskComment {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  body      String   @db.LongText
  taskId    String
  authorId  String
  task      Task     @relation(fields: [taskId], references: [id], onDelete: Cascade)
  author    User     @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([taskId, createdAt])
  @@index([authorId])
  @@map("task_comments")
}

model Token {
  id        String    @id @default(cuid())
  createdAt DateTime  @default(now())
  usedAt    DateTime?
  type      TokenType
  email     String
  token     String    @unique @db.VarChar(500)
  expiresAt DateTime
  userId    String?
  agencyId  String?
  // Keep this as string to avoid coupling invite flows to Role enum.
  // (We use metadata for most invite payload anyway.)
  role      String?
  metadata  String?   @db.LongText
  agency    Agency?   @relation(fields: [agencyId], references: [id])
  user      User?     @relation(fields: [userId], references: [id])

  @@index([type, email])
  @@index([agencyId], map: "tokens_agencyId_fkey")
  @@index([userId], map: "tokens_userId_fkey")
  @@map("tokens")
}

model Client {
  id                    String                  @id @default(cuid())
  createdAt             DateTime                @default(now())
  updatedAt             DateTime                @updatedAt
  name                  String                  @unique
  domain                String                  @unique
  industry              String?
  targets               String?                 @db.LongText
  status                Status                  @default(PENDING)
  canceledEndDate       DateTime?               // When status is CANCELED, optional end date to display
  keepDashboardAfterEndDate Boolean?            @default(false) // If true, after end date â†’ DASHBOARD_ONLY; else ARCHIVED
  loginUrl              String?
  username              String?
  password              String?
  notes                 String?
  // Stores extended onboarding / account details as JSON string.
  accountInfo           String?                 @db.LongText
  ga4AccessToken        String?                 @db.Text
  ga4RefreshToken       String?                 @db.Text
  ga4PropertyId         String?
  ga4AccountEmail       String?
  ga4ConnectedAt        DateTime?
  // Google Ads (PPC) integration fields
  googleAdsAccessToken  String?                 @db.Text
  googleAdsRefreshToken String?                 @db.Text
  googleAdsCustomerId   String?
  googleAdsAccountEmail String?
  googleAdsConnectedAt  DateTime?
  vendasta              Boolean                  @default(false)
  userId                String
  // Managed service fields (denormalized / summary on client)
  managedServiceStatus       ManagedServiceStatus? @default(none)
  managedServicePackage     ManagedServicePackage?
  managedServicePrice       Decimal?               @db.Decimal(10, 2)
  managedServiceRequestedDate DateTime?
  managedServiceActivatedDate DateTime?
  managedServiceCanceledDate  DateTime?
  managedServiceEndDate      DateTime?             @db.Date
  belongsToAgencyId     String?
  isAgencyOwnDashboard   Boolean                  @default(false)
  aiSearchSerpCache     AiSearchSerpCache?
  backlinkTimeseries    BacklinkTimeseries[]
  backlinks             Backlink[]
  user                  User                    @relation(fields: [userId], references: [id])
  belongsToAgency       Agency?                 @relation("ClientsBelongingToAgency", fields: [belongsToAgencyId], references: [id])
  ga4Metrics            Ga4Metrics?
  keywords              Keyword[]
  rankedKeywordsHistory RankedKeywordsHistory[]
  reportSchedules       ReportSchedule[]
  seoReports            SeoReport?
  targetKeywords        TargetKeyword[]
  Task                  Task[]
  topPages              TopPage[]
  trafficSources        TrafficSource[]
  clientUsers           ClientUser[]
  managedServices       ManagedService[]

  @@index([name, domain])
  @@index([userId], map: "clients_userId_fkey")
  @@index([belongsToAgencyId])
  @@map("clients")
}

model ManagedService {
  id                       String   @id @default(cuid())
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  agencyId                 String
  clientId                 String
  packageId                String   // foundation | growth | domination | custom
  packageName              String
  monthlyPrice              Int      // cents
  commissionPercent        Int
  monthlyCommission        Int      // cents
  startDate                DateTime
  status                   String   @default("ACTIVE") // ACTIVE | CANCELED
  stripeSubscriptionItemId String?  @db.VarChar(255)
  agency                   Agency   @relation(fields: [agencyId], references: [id], onDelete: Cascade)
  client                   Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([agencyId])
  @@index([clientId])
  @@map("managed_services")
}

// Track every managed service activation request for Super Admin (audit / reporting).
model ManagedServiceRequest {
  id                 String   @id @default(cuid())
  createdAt          DateTime @default(now())
  agencyId           String   @db.VarChar(191)
  agencyName         String   @db.VarChar(255)
  agencyEmail        String?  @db.VarChar(255)
  clientId           String   @db.VarChar(191)
  clientName         String   @db.VarChar(255)
  packageId          String   @db.VarChar(80)
  packageName        String   @db.VarChar(255)
  monthlyPriceCents  Int
  startDate         DateTime @db.Date
  managedServiceId   String?  @db.VarChar(191)

  @@index([agencyId])
  @@index([createdAt])
  @@map("managed_services_requests")
}

model AgencyAddOn {
  id                       String   @id @default(cuid())
  createdAt                DateTime @default(now())
  agencyId                 String
  addOnType                String   // credit_pack | extra_slots | map_pack
  addOnOption              String   // e.g. "100", "500", "5_slots", "starter", "growth", "pro"
  displayName              String
  details                  String?  @db.VarChar(500)
  priceCents               Int
  billingInterval          String   // one_time | monthly
  stripeSubscriptionItemId String?  @db.VarChar(255)
  agency                   Agency   @relation(fields: [agencyId], references: [id], onDelete: Cascade)

  @@index([agencyId])
  @@map("agency_add_ons")
}

model Notification {
  id        String   @id @default(cuid())
  type      String   @db.VarChar(80)   // managed_service_request, cancellation, etc.
  title     String   @db.VarChar(255)
  message   String   @db.Text
  link      String?  @db.VarChar(500)
  read      Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([type])
  @@index([createdAt])
  @@map("notifications")
}

model ClientUser {
  id           String          @id @default(cuid())
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt
  clientId     String
  userId       String
  invitedById  String?
  clientRole   ClientUserRole  @default(CLIENT)
  status       ClientUserStatus @default(PENDING)
  invitedAt    DateTime        @default(now())
  acceptedAt   DateTime?

  client       Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user         User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  invitedBy    User?           @relation("ClientUserInvitedBy", fields: [invitedById], references: [id])

  @@unique([clientId, userId])
  @@index([clientId])
  @@index([userId])
  @@index([invitedById])
  @@map("client_users")
}

model SeoReport {
  id                 String          @id @default(cuid())
  createdAt          DateTime        @default(now())
  updatedAt          DateTime        @updatedAt
  reportDate         DateTime
  period             String
  totalSessions      Int
  organicSessions    Int
  paidSessions       Int
  directSessions     Int
  referralSessions   Int
  totalClicks        Int
  totalImpressions   Int
  averageCtr         Float
  averagePosition    Float
  bounceRate         Float
  avgSessionDuration Float
  pagesPerSession    Float
  conversions        Int
  conversionRate     Float
  clientId           String          @unique
  activeUsers        Int?
  emailSubject       String?
  eventCount         Int?
  keyEvents          Int?
  newUsers           Int?
  recipients         String?         @db.LongText
  scheduleId         String?
  sentAt             DateTime?
  status             String          @default("draft")
  client             Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  schedule           ReportSchedule? @relation(fields: [scheduleId], references: [id])

  @@index([clientId, reportDate])
  @@index([scheduleId])
  @@map("seo_reports")
}

model ReportSchedule {
  id           String      @id @default(cuid())
  createdAt    DateTime    @default(now())
  updatedAt    DateTime    @updatedAt
  frequency    String
  dayOfWeek    Int?
  dayOfMonth   Int?
  timeOfDay    String      @default("09:00")
  recipients   String      @db.LongText
  emailSubject String?
  isActive     Boolean     @default(true)
  clientId     String
  lastRunAt    DateTime?
  nextRunAt    DateTime?
  client       Client      @relation(fields: [clientId], references: [id], onDelete: Cascade)
  reports      SeoReport[]

  @@index([clientId])
  @@index([isActive, nextRunAt])
  @@map("report_schedules")
}

model Keyword {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  keyword          String
  searchVolume     Int
  difficulty       Float?
  cpc              Float?
  competition      String?
  currentPosition  Int?
  previousPosition Int?
  bestPosition     Int?
  googleUrl        String?
  serpFeatures     String?  @db.LongText
  totalResults     Int?
  clicks           Int      @default(0)
  impressions      Int      @default(0)
  ctr              Float    @default(0)
  clientId         String
  locationName     String?  @db.VarChar(255)
  client           Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, keyword])
  @@index([clientId, currentPosition])
  @@map("keywords")
}

model RankedKeywordsHistory {
  id            String   @id @default(cuid())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  totalKeywords Int
  top3          Int      @default(0)
  top10         Int      @default(0)
  page2         Int      @default(0)
  pos21_30      Int      @default(0)
  pos31_50      Int      @default(0)
  pos51Plus     Int      @default(0)
  clientId      String
  month         Int
  year          Int
  client        Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, month, year])
  @@index([clientId, year, month])
  @@map("ranked_keywords_history")
}

model Backlink {
  id           String    @id @default(cuid())
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt
  // DataForSEO can return very long URLs; VARCHAR(191) overflows in MySQL.
  sourceUrl    String    @db.Text
  targetUrl    String    @db.Text
  anchorText   String?   @db.Text
  domainRating Float?
  urlRating    Float?
  traffic      Int?
  isFollow     Boolean   @default(true)
  isLost       Boolean   @default(false)
  firstSeen    DateTime?
  lastSeen     DateTime?
  clientId     String
  client       Client    @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId, isLost])
  @@index([clientId, domainRating])
  @@map("backlinks")
}

model OnboardingTemplate {
  id          String            @id @default(cuid())
  createdAt   DateTime          @default(now())
  updatedAt   DateTime          @updatedAt
  name        String
  description String?
  isDefault   Boolean           @default(false)
  agencyId    String?           // null = global template (e.g. "Standard SEO Onboarding") shown to all
  tasks       OnboardingTask[]
  agency      Agency?           @relation(fields: [agencyId], references: [id], onDelete: Cascade)

  @@index([agencyId])
  @@map("onboarding_templates")
}

model OnboardingTask {
  id             String             @id @default(cuid())
  createdAt      DateTime           @default(now())
  updatedAt      DateTime           @updatedAt
  title          String
  description    String?
  category       String?
  priority       String?
  estimatedHours Int?
  order          Int                @default(0)
  templateId     String
  template       OnboardingTemplate @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([templateId, order])
  @@map("onboarding_tasks")
}

model TopPage {
  id             String   @id @default(cuid())
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt
  url            String
  organicPos1    Int      @default(0)
  organicPos2_3  Int      @default(0)
  organicPos4_10 Int      @default(0)
  organicCount   Int      @default(0)
  organicEtv     Float    @default(0)
  organicIsNew   Int      @default(0)
  organicIsUp    Int      @default(0)
  organicIsDown  Int      @default(0)
  organicIsLost  Int      @default(0)
  paidCount      Int      @default(0)
  paidEtv        Float    @default(0)
  rawData        String?  @db.LongText
  clientId       String
  client         Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, url])
  @@index([clientId, organicEtv])
  @@map("top_pages")
}

model TrafficSource {
  id                      String   @id @default(cuid())
  createdAt               DateTime @default(now())
  updatedAt               DateTime @updatedAt
  name                    String
  value                   Float    @default(0)
  totalKeywords           Int      @default(0)
  totalEstimatedTraffic   Float    @default(0)
  organicEstimatedTraffic Float    @default(0)
  averageRank             Float?
  rankSampleSize          Int      @default(0)
  clientId                String
  client                  Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, name])
  @@index([clientId])
  @@map("traffic_sources")
}

model BacklinkTimeseries {
  id                       String   @id @default(cuid())
  createdAt                DateTime @default(now())
  updatedAt                DateTime @updatedAt
  date                     DateTime
  newBacklinks             Int      @default(0)
  lostBacklinks            Int      @default(0)
  newReferringDomains      Int      @default(0)
  lostReferringDomains     Int      @default(0)
  newReferringMainDomains  Int      @default(0)
  lostReferringMainDomains Int      @default(0)
  rawData                  String?  @db.LongText
  clientId                 String
  client                   Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, date])
  @@index([clientId, date])
  @@map("backlink_timeseries")
}

model AiSearchSerpCache {
  id                   String   @id @default(cuid())
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt
  fetchedAt            DateTime
  checkedKeywords      Int      @default(0)
  aiOverviewCitedPages Int      @default(0)
  aiModeCitedPages     Int      @default(0)
  aiOverviewCitedUrls  String?  @db.LongText
  aiModeCitedUrls      String?  @db.LongText
  clientId             String   @unique
  client               Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId, updatedAt])
  @@map("ai_search_serp_cache")
}

model TargetKeyword {
  id               String   @id @default(cuid())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt
  keyword          String
  searchVolume     Int?
  cpc              Float?
  competition      String?
  competitionValue Float?
  monthlySearches  String?  @db.LongText
  keywordInfo      String?  @db.LongText
  locationCode     Int?
  locationName     String?
  languageCode     String?
  languageName     String?
  serpInfo         String?  @db.LongText
  serpItemTypes    String?  @db.LongText
  googleUrl        String?
  googlePosition   Int?
  previousPosition Int?
  seResultsCount   String?
  clientId         String
  client           Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@unique([clientId, keyword])
  @@index([clientId, searchVolume])
  @@index([clientId, googlePosition])
  @@map("target_keywords")
}

model Ga4Metrics {
  id                 String   @id @default(cuid())
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt
  startDate          DateTime
  endDate            DateTime
  activeUsers        Int
  // Legacy fields kept for backward compatibility with existing DB rows.
  totalUsers         Int?
  engagedSessions    Int?
  eventCount         Int
  newUsers           Int
  keyEvents          Int
  totalSessions      Int
  organicSessions    Int
  directSessions     Int
  referralSessions   Int
  paidSessions       Int
  bounceRate         Float
  avgSessionDuration Float
  pagesPerSession    Float
  conversions        Int
  conversionRate     Float
  newUsersTrend      String?  @db.LongText
  activeUsersTrend   String?  @db.LongText
  events             String?  @db.LongText
  clientId           String   @unique
  client             Client   @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId, endDate])
  @@index([clientId, createdAt])
  @@map("ga4_metrics")
}

enum Role {
  SUPER_ADMIN
  ADMIN
  AGENCY
  SPECIALIST
  USER
}

enum ClientUserRole {
  CLIENT
  STAFF
}

enum ClientUserStatus {
  PENDING
  ACTIVE
}

enum AgencyRole {
  SPECIALIST
  MANAGER
  OWNER
}

enum TaskStatus {
  TODO
  IN_PROGRESS
  REVIEW
  DONE
}

enum Status {
  ACTIVE
  PENDING
  REJECTED
  DASHBOARD_ONLY   // No managed service
  CANCELED         // Managed service canceled (use canceledEndDate for end date)
  SUSPENDED        // Client suspended
  ARCHIVED         // Past/deleted client (REJECTED kept for backward compatibility)
}

enum ManagedServiceStatus {
  none
  pending
  active
  canceled
  suspended
  archived
}

enum ManagedServicePackage {
  foundation
  growth
  domination
  custom
}

enum BillingType {
  paid
  free
  custom
}

enum TokenType {
  EMAIL_VERIFY
  INVITE
  MAGIC_LOGIN
}
